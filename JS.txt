一、变量
1、变量：在内存中开辟空间用来存放数据；
2、只声明，不赋值： undefoned；不声明，不赋值：报错；不声明，只赋值：正常；
3、声明变量并赋值：变量初始化；
4、变量的命名规范：变量名必须有意义；
5、交换两个变量： 用一个中间变量来赋值。

二、数据类型
1、JS的变量数据类型是：
1)只有在程序运行的过程中，根据等号右边的值来确定的。 
eg: var num = 10  // 数值型； var str = 'pink'; // 字符串型
2)JS拥有动态类型，同时也意味着相同的变量可用作不同的类型
eg: var x = 3; // x为数字  var x = 'all' // x为字符串

2、数据类型的分类
JS把数据类型分为两类：
简单数据类型：Number、String、Boolean、Underfined、Null
复杂数据类型：Object

1）简单数据类型：
1.Number 分整型和小数型；
JS中八进制前面加0，十六进制前面加0x；
isNaN() 判断非数字 是返回false,不是返回true；
2.字符串型
1)String推荐使用单引号；'String'
2)字符串转义符用 \ 开头，但是这些转义符要写到引号里面去
\n 换行;  \ \  斜杠\ ;  \'  '单引号; \* *双引号;  \t tab缩进;  \xa0  空格
3)字符串长度通过length属性可以获取整个字符串的长度
eg: str.length
4)字符串拼接 
字符串 + 任意类型 都是字符串 
数值相加，字符相连，引引加加
变量不能加引号，加引号就变成字符串
5）布尔型Boolean
参与加法运算
undefined + 数字 = undefined
null + 1 = 1
6）获取检测变量数据类型 typeof num
7)  字面量：表示如何表达这个值
数字字面量：8 9 10
字符串字面量： ‘哈哈哈’
布尔字面量：true, false
8)  数据类型的转换
1.转换为字符串：
toString()  num.toString()
String()  String( num )
加号拼接字符串 + ' '
2.转换为数字型***
parseInt( age )  取整，会去掉小数点和单位
parseFloat( 3.14 )
Number( '12' )
利用- * /  eg: '12' - 0
3.转换为布尔型
Boolean() 函数
 ' ', 0, NaN, null, undefined代表空、否定的值会被转换成false
其余转换为true；

扩展
1、JS属于解释性语言；
2、标识符、关键字、保留字：
标识符：为变量、属性、函数、参数取的名字。不能是关键字、保留字

三、运算符
1、算术运算符：+ — * / %取余，浮点数算术运算有问题
不要直接判断两个浮点数是否相等
取余主要用来判断是否整除，余数为0
2、表达式：由数字、运算符和变量组成的式子；最终返回一个结果返回值；
把右边的值赋值给左边：var num = 1 + 1
3、递增( ++ )和递减( -- )
1) 前置递增：++num  先自加，后返回值
2) 后置递增：num++  先返回原值，后自加1
4、比较运算符：返回的是一个布尔值（true / false）作为运算的结果
==  会转型  18 == ‘ 18 ’  // true  会把字符串型的转换为数字型
===  !==  全等 要求值和类型完全一样
5、逻辑运算符：进行布尔值运算，返回的也是布尔值，用于多个条件判断
&&    ||    !
短路运算：当有多个表达式（值）时，左边的表达式可以确定就不看右边
表达式1 &&  表达式2  如果1为真，则返回2；如果1为假，则返回1 
eg: 123 && 456   // 456
如果有空的或者否定的为假，其余是真的；0  ' ' undefined  null NaN

表达式1 ||  表达式2  如果1为真，则返回1；如果1为假，则返回2
eg: 123 || 456   //  123
6、赋值运算符：把数据赋给变量 +=  -=  *=
num = num + 1  // num++
num = num + 2  // num += 2
7、运算符优先级
小括号 ()  
一元运算符 ++  --  !	
算术运算符 * / + -
关系运算符  > >= < <=   返回true 或false
相等运算符 ==  !==  === !==
逻辑运算符  &&  || 
赋值运算符 =
逗号运算符 ，
一元运算符里面的逻辑非优先级很高
逻辑与比逻辑或优先级高

四、JS流程控制
1、顺序结构
2、分支结构：根据不同条件、执行不同的路径代码（多选一）
，得到不同的结果
if  //  如果if表达式条件为真，则执行花括号里面的语句
//  如果if条件表达式为假，则不执行花括号里面的代码，
执行if 后面语句的代码
if ( 条件表达式 ) {
// 执行语句
}

// 如果if表达式条件为真，则执行花括号里面的语句1; 
否则执行语句2；最终只能有一个语句执行；
if （条件表达式）{
// 执行语句1
} else {
// 执行语句2
}

if else if 多分支语句
if （条件表达式1）{
// 语句1
} else if （条件表达式2）{
// 语句2
} else if （ 条件表达式3）{
//语句3
} else {
//最后的语句
}
3、三元表达式：由三元运算符组成的式子
条件表达式 ？表达式1 ： 表达式2
//  如果条件表达式结果为真 则返回表达式1，如果条件表达式为假
，则返回表达式2的值。
var num = 10
var result = num > 5 ? '是的' : '不是的'  // 表达式有返回值
4、switch 语句：针对变量设置一系列的特定值的选项
switch 转换、开关  case 小例子或者选项的意思
switch(表达式) {  
case value1:
执行语句1；
break;
case value2:
执行语句2；
break;
...
default:
执行最后的语句；
}
思路：利用表达式的值 和 case后面的选项值相匹配，如果匹配上
就执行该case里面的语句，如果没有匹配上，那么执行default里面
的语句。
**开发时经常把表达式写成变量
**变量的值和case里面的值相匹配的时候是全等，是值和数据类型
一致才可以。
**break  如果当前的case里面没有break，则不退出switch是继续
执行下一个case.
5、switch 和 if else if 语句的区别
①一般情况可以互换；
②switch...case 处理case为确定值的情况；而if..else..用于范围判断
（大于或等于某个范围）
③switch进行条件判断后直接执行到条件语句，效率更高；
而if..else..语句有几种条件，就得多判断几次。
④当分支比较少时，if..else..效率更高
⑤当分支比较多时，switch执行的效率更高

6、循环的目的：可以重复执行某些代码
三种循环语句： for循环； while 循环；do...while..循环
 循环体：一组被重复执行的语句称为循环体。
for ( 初始化变量；条件表达式；操作表达式 ) {
//  循环体
}
for 循环执行相同的代码
for 循环执行不同的代码
for ( var i=1; i<=100; i++ ) {
console.log( i )
}
for 循环重复某些相同的操作
for 循环重复某些不同的操作

双重for循环：语法结构
for (外层初始化变量；外层条件表达式；外层操作表达式) {
for(里层初始化变量；里层条件表达式；里层操作表达式) {
执行语句
}
}
外层循环执行一次，里面的循环执行全部

当条件表达式为true，则执行循环体；否则退出循环；
while (条件表达式) {
// 循环体
操作表达式
}
先执行循环体，再判断条件
do {
// 循环体
} while (条件表达式)

continue 关键字：用于立即跳出当前次循环，继续下一次循环
break关键字：用于立即跳出整个循环

命名规范：
变量、函数的命名必须要有意义
变量名称一般是名词
函数名称一般是动词
操作符的左右两侧各保留一个空格

单行注释规范
单行注释前面注意有个空格
小括号前后有空格

五、数组：是指一组数据的集合，其中每个数据称作元素，在数组中可以存
放任意类型的元素，数组是一组数据存储在单个变量名下的优雅方式。
1、创建数组
利用new创建数组；
var arr = new Array();  // 创建一个新的空数组
利用数组字面量创建数组；
var arr = [ ]
数组里面的数据用逗号分隔；
数组的字面量是方括号[ ]
声明数组并赋值称为数组的初始化
2、获取数组中的元素 格式  数组名[索引号]
数组的索引（下标从0开始）	
3、遍历数组：把数组元素从头到尾访问一次
数组的长度是元素个数arr.length动态监测数组元素个数
4、数组中新增元素
1.通过修改length长度新增数组元素;
2.通过修改数组索引新增数组元素
不要直接给数组名赋值，否则里面的元素都没有
筛选数组（去重）、翻转数组、冒泡排序

六、函数：就是封装了一段可以被重复执行调用的代码块，
目的：就是让大量代码重复使用。
1.函数使用：声明函数
function 函数名() {  // 形参默认为undefined
// 函数体
}
函数不调用，自己不执行
2.调用函数：函数名()
3.形参和实参：
function 函数名(形参1，形参2...) {  // 形式上的参数

}
函数名(实参1， 实参2....)  //  实际的参数
形参是接收实参的
4.形参和实参个数匹配；// 尽量匹配
1.形参与实参个数一致，则正常输出；
2.如果实参个数多于形参，会取到形参个数；
3.如果实参个数小于形参个数，NaN
形参可以看做是没有声明的变量；
函数可以带参数也可以不带参数；
5.函数的返回值
1.return 语句
function 函数名 () {
return 需要返回的结果；
}
函数名();
函数只是实现某种功能，最终的结果需要返回给函数的调用者
函数名() ，通过return语句来实现的
只要函数遇到return 就把后面的结果返回给函数的调用者
函数名() =  return 后面的结果
6.return 终止函数
return 语句之后的代码不被执行；一次只能返回一个值，
如果有多个值，逗号隔开，以最后一个为准；
可以返回一个数组；
函数有return，返回的是return后面的值；
没有return,则返回的是Undefined；
return 不仅可以退出循环，还可以返回return语句中的值，
同时还可以结束当前函数体的代码；
7. arguments 的使用
是当前函数的内置对象，存储了传递的所有实参；
伪数组：
1.具有length属性；
2.按照索引的方式进行存储；
3.它没有真正数组的一些方法；
4.可以按照数组的方式遍历arguments；
8.利用函数封装翻转数组
1. 单层循环  arr.length-1 ；新数组盛放；
冒泡排序
1.双层循环：趟数arr.length-1
交换的此时：arr.length-i-1
两个变量交换
9.函数可以调用另外一种函数
10.函数的两种声明方式：
1.利用函数关键字定义函数
function fn() {

}
2.函数表达式(匿名函数	)
var 变量名 = function() {};
var fun = function() {
console.log('我是函数表达式')
}
fun()
1)fun是变量名，不是函数名
2)函数表达式声明方式跟声明变量差不多，只不过变量里面
存的是值，而函数表达式里面存的是函数；
3)函数表达式可以进行参数传递

七、作用域：可用性代码范围，减少命名冲突；
全局作用域：整个script标签
局部作用域：在函数内部起作用和效果；
块级作用域 { }
变量作用域：全局变量和局部变量
全局变量： 在全局作用域下的变量，占内存
在函数内部没有声明直接赋值的变量也是全局变量
局部变量：只在函数内部使用，节约内存
函数的形参也可以看做局部变量
作用域链：
内部函数可以访问外部函数变量，链式一层一层查找
哪些函数可以被访问。

八、预解析
js引擎：预解析、代码执行
把var  function提升到当前作用域的最前面；
变量预解析（变量提升）
变量声明提升，赋值不提升	
函数预解析（函数提升）
函数声明提升，不调用函数	

九、对象：一个具体的事物
对象是一组无序的相关属性和方法的集合。
属性：事物的特征；
方法：事物的行为；
1.创建对象的三种方式
字面量、new Object 、构造函数
1)利用字面量创建对象
var obj = { }  // 创建了一个空对象
var obj = {
uname: '张三';
age: 16,
sayHi: function() {
console.log('hi~')
}
}
// 里面的属性和方法采取键值对；键 属性名 ：值  属性值
// 多个属性或者方法中间用逗号分隔
// 方法冒号后面跟一个匿名函数
2.调用对象的属性
对象名.属性名 obj.uname
对象名[ '属性名' ]
3.调用对象的方法 
对象名.方法名()    //  obj.sayHi()
4.变量、属性、函数、方法的区别
相同点：变量和属性都是用来存储数据的。
不同点：变量单独声明并赋值，使用时直接写变量名，单独存在；
   属性在对象里面，不需要声明，使用时对象.属性名
函数和方法
相同点：都是实现某种功能；
不同点：函数是单独声明并调用，函数名()  单独存在
   方法在对象里面	调用的时候 对象.方法名()

2) 利用new Object 创建对象
var obj = new Object()  // 创建了一个空对象
obj.uname = '张三'；
obj.age = 18；
obj.sex = '男'；
obj.sayHi = function () {
console.log('hi~')
}
// 利用等号 = 赋值的方法添加对象的属性和方法
// 每个属性和方法之间用分号结束

3）利用构造函数创建对象：因为前面两种方式一次只能创建一个对象
里面很多的属性和方法是大量相同的，只能复制，因此可以利用函数的
方法，重复这些相同的代码。把这个函数称为构造函数。
又因为这个函数里面封装的不是普通代码，而是对象。
构造函数 就是把对象里面一些相同的属性和方法抽象出来封装到函数
里面。
// 构造函数的语法格式
function 构造函数名() {     // 声明构造函数
this.属性 = 值；
this.方法 = function() {}
}
new 构造函数名()   // 调用构造函数
//  构造函数名字首字母要大写
//  构造函数不需要return就可以返回结果
//  调用构造函数必须使用 new
function Star(uname, age, sex) {
this.name = uname;
this.age = age;
this.sex = sex;
this.sing = function(sang) {
console.log(sang)
}
}
var ldh = new Star('刘德华', 18, '男 ');  //  返回的是一个对象
ldh.sing('冰雨')  ldh.name   ldh['sex']

构造函数和对象的区别：
构造函数：明星  泛指的某一大类   它类似java里面的  类(class)
对象： 特指某一具体的事物 刘德华={name: '刘德华', age: 18}
利用构造函数创建对象的过程称为对象的实例化。

new关键字的执行过程：
1. new构造函数可以在内存中创建了一个空对象；
2. this指向刚才创建的空对象
3. 执行构造函数里面的代码给这个空对象添加属性和方法
4. 返回这个新对象。

2、遍历对象属性
for...in 用于对于数组或对象的属性进行循环操作
for (变量 in 对象) {

}
for (var k in ibj) {
console.log(k)  // 变量输出得到的是属性名
console.log(obj[k])  //  obj[k] 得到的是属性值
}
// 使用for in 里面的变量，喜欢写key 或者 k

3.  内置对象：Math、Date、Array、String
JS对象：自定义对象、内置对象、浏览器对象
1) Math对象
不是一个构造器，所以不需要new调用，而是直接使用
里面的属性和对象。
Math.PI   //  圆周率
Math.floor()   //  向下取整，往小了取值
Math.ceil()  //  向上取整，往大了取值
Math.round() //  四舍五入
Math.abs()  //  绝对值，隐式转换会把字符串型-1转换成数字1
Math.max() / Math.min()  //  求最大值和最小值
Math.random()  返回一个随机小数[0, 1)，方法里面不跟参数
返回一个随机小数
2) Date 对象 通过new 操作符
1.参数的四种基本形式
 如果没有提供参数，那么新创建的Date对象表示实例化时刻的日期和时间
var date = new Date() 
一个时间戳
字符串 '2019-1-1 0:0:0'
数字型 2019, 10, 11
 		2.获得Date总的毫秒数，valueOf()、getTime()、Date.now() 
1) let date = new Date()
date.valueOf();  // 获取时间戳
date.getTime(); //  获取事件戳
Date.now() // 获取时间戳
+new Date() // 获取时间戳
2）倒计时案例  获取时间戳就是毫秒数
d = parseInt(总秒数/60/60/24) // 计算天数
h = parseInt(总秒数/60/60%24) // 计算小时
m = parseInt(总秒数/60%60) // 计算分钟
s = parseInt(总秒数%60) // 计算秒
3)Array 数组对象
1. 数组创建的两种方式
1.利用字面量  var arr = [ ];
var arr = [1, 2, 3]
2.利用new Array()
var arr1 = new Array()  // 创建了一个空数组
var arr1 = new Array(2) // 表示数组长度为2，里面有2个空的数组元素
var arr1 = new Array(2, 3) // 等价于[2, 3]
2.检测是否为数组
instanceof 可以检测是否为数组 arr instanceof array
Array.isArray(参数)
3.添加删除数组元素
push(ele1, ele2, ele...) 方法将一个或多个元素添加到数组的末尾会改变原数组，并返回该数组的新长度。
unshift((ele1, ele2, ele...) 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。
pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度
shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。
4.数组排序
arr.reverse()  返回颠倒后的数组，会改变原数组。
arr.sort()  对数组进行排序，并返回排序后的数组。
5.筛选数组
filter(callback(element[, index[, array]])) 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
var new_array = arr.map(function callback(currentValue[, index[, array]]) {
			 // Return element for new_array 
		}[, thisArg])
6.查找索引
arr.indexOf(searchElement[, fromIndex])方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。
     arr.lastIndexOf(searchElement[, fromIndex]) 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。
7.数组去重：遍历旧数组，拿旧数组元素查询新数组，如果有则不添加。（重点案例）
8.数组转换为字符串
1)   arr.toString()  返回指定字符串
2）arr.join(分隔符)
9.链接两个数组
var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])  返回新的数组
删除数组中的元素
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])有返回值，返回累计处理的结果。
arr.every(callback(element[, index[, array]])[, thisArg]) 测试一个数组内的所有元素是否都能通过某个指定函数的测试
arr.some(callback(element[, index[, array]])[, thisArg])测试数组中是不是至少有1个元素通过了被提供的函数测试
4）字符串对象
1. 基本包装类型：把简单数据类型包装成了复杂数据类型；三种特殊的引用类型：String Number
Boolean
2. 字符串的不可变性
3. 根据字符串返回位置：str.indexOf(元素，[开始的位置])
4.根据位置返回字符str[index] h5新增、charAt(index)、charCodeAt(index)
5. 拼接和截取字符串
   concat(str1, str2, str3...)  用于连接两个或者多个字符串，等效于+
   substr('截取的起始位置', '截取的个数')
   substring(strat, end)  从start位置开始截取到end位置，end取不到。
6.替换字符串以及转换为数组
   替换字符 replace('被替换的字符', '替换为的字符') 它只会替换第一个字符。
   字符转换为数组  split('分隔符')

十、DOM简介
1、DOM树：文档（页面）、元素（标签）、节点（标签、属性、文本、注释）
2、获取元素：
根据ID获取，根据标签名获取、通过H5新增的方法获取，特殊元素获取
getElementById() 返回的是对象
getElementsByTagName() 返回的是伪数组
获取父元素里面的子元素
element.getElementByTagName('标签名')   //  ol[0].getElementByTagName('li')
根据类名获取元素
document.getElementsByClassName('类名')
返回指定选择器的第一个元素对象，里面的选择器需要加符号
document.querySelector('.box') // querySelector('.box')
返回指定选择器所有的元素
document.querySelectorAll('.box')  
3、获取特殊元素
document.body()	 // 获取body元素
document.documentElement  // 获取html元素
4、事件基础
事件三要素：事件源：事件触发的对象 （按钮）
     事件类型：什么事件比如鼠标点击（onClick）、滑动、键盘按下
     事件处理程序：通过一个函数赋值的方式完成 btn.onClick = function() {}
改变元素的内容、属性；以下都是属性，采取等于
element.innerText  //  去除标签、空格、换行
element.innerHtml  //  包括标签、空格、换行
操作元素的属性
1、获取元素 let ldh = getElementById('ldh')  let img = getElementById('img')
2、注册事件及处理程序 ldh.onclick = function() {
img.src = 'hsakhauhhk'
}
3、表单元素的属性操作
type、value、checked、selected、disabled
btn.onclick = function() {
input.value =  '改变input输入框里面的值'
btn.disabled = true
this. disabled = true  // 同上效果，this 指向的是事件函数的调用者
}
案例：隐藏密码钥文点击切换
同一个按钮重复点击，利用一个flag变量，来判断flag的值
4、修改样式属性大小、颜色、位置
1. element.style  行内样式操作  // div.style.backgroundColor = 'pink'
JS里面的样式采取驼峰命名法，行内样式，权重比较高。
样式比较少，或者功能比较简单的情况下使用。
2. element.className   类名样式操作   // 给元素添加类名
// 让当前元素的类名改为了change，会覆盖原先的类名。
this.className = 'change'
// 如果想保留原先的类名，使用多类名选择器
this.className = 'first change'

5、排他思想
所有元素全部清除样式，给当前元素设置样式。

6、表单全选和取消全选
思路：1.点击全选：复选框跟随全选框
2.循环点击复选框，每次点击再循环一遍复选框，判断有无没选中的，设置变量来控制全选按钮是否选中

7、 获取元素的自定义属性
1.操作内置属性如：id，class  
使用element.属性
2.操作自定义属性： // 程序员自己添加的属性 index = '1'
element.getAttribute('属性')

8、设置元素的属性值
1.element.属性 = ‘值
   div.className = 'navs'
2.element.setAttribute('属性'， ‘值’)  //  操作自定义或者原先自带的属性
   div.seAttribute('class', 'navs')  

9、移除属性
element.removeAttribute('属性')

10、tab栏自定义切换
思路：排他思想、自定义属性
 
11、H5新增自定义属性：在页面中保存使用数据，有些自定义属性容易引起歧义
  规定自定义属性data-开头作为属性名并且赋值

<div data-index="1"></div>
或者JS设置
div.setAttribute('data-index', 1)

获取自定义属性
div.getAttribute('data-index')
// 如果自定义属性里面有多个-连接的单词，获取的时候采取驼峰命名法，只能获取data-开头的
H5新增element.dataset.index  或者 element.dataset['index']    //  ie11以上才支持

十一、节点操作
1、DOM提供的方法获取元素繁琐，逻辑性不强。
2、利用父子兄节点操作，逻辑性强，兼容性稍差，更简单一些。
节点概述：节点一般至少包括nodeType、nodeName、nodeValuez这三个基本属性
节点操作主要操作的是元素节点。
父节点：parentNode  //  得到的是离元素最近的父节点，如果找不到就返回 null
子节点：childNodes  //  返回包含子节点的集合，包含元素节点、文本节点等，一般不提倡
   children  // 返回所有子元素的节点。实际开发常用。
3、节点操作获取第一个子元素和最后一个子元素
firstChild  获取第一个子节点，不管是文本还是元素都可以拿到。
lastChild  获取最后一个节点，不管是文本还是元素都可以拿到。
firstElementChild 获取第一个子元素节点  IE9以上支持。
lastElementChild 获取最后一个子元素节点，IE9以上支持。
下面两个最实用：
// 实际开发中 ol.children[0]  第一个子元素节点
ol.children[ol.children.length-1]  最后一个元素节点

案例：下拉菜单，采用子节点对应得显示。

4、兄弟节点
 nextSibling  返回当前元素的下一个节点，包含文本节点或者元素节点，找不到就返回null
 previousSibling  返回当前元素的上一个节点，包含文本节点或者元素节点，找不到就返回null

nextElementSibling 下一个兄弟节点,找不到就返回null  IE9以上支持。
previousElementSibling 上一个兄弟节点,找不到就返回null  IE9以上支持。

5、页面添加一个新元素。1创建元素，2添加元素。

1.动态创建元素节点	
var li = document.createElement('li')
2.在子节点末尾添加节点
父级.appendChild(子级)   //  将一个节点添加到指定父节点的子节点末尾
ul.appendChild(li)
在子节点前面添加节点
父级.insertBefore(child，指定元素)  
ul.insertBefore(lili,  ul.children[0])

留言板案例：
添加节点，给元素添加内容	
删除留言板
给li赋值时多加一个删除的链接，阻止链接跳转javascript:void(0); 或者 javascript:;
删除的是当前链接的父节点li

6、删除节点
父节点.removeChild(子节点)  //  删除父节点中的子节点

7、复制节点
node.cloneNode()  // 拷贝节点
如果括号为true，就是深拷贝，会复制标签里面的内容
如果参数为空或者false，就是浅拷贝，只复制节点本身，不包括里面的子节点

案例动态生成表格
思路：根据数据动态添加行和列
1、有几条数据就创建几行，2.有几个属性就创建几个单元格，3、在每行追加删除单元格

8、三种动态创建元素的区别
window.onload = function () {  //  页面加载完毕加载JS
document.write('<div>123</div>')
}
document.write( )  页面文档流加载完毕(比如事件)会导致页面重绘
element.innerHTML  采取数组形式效率最高，字符串效率最低
document.creatElement( )  效率稍微低一点

十二、事件高级
1、注册事件的两种方式
传统方式： on开头的  onclick，特点：注册事件的唯一性；同时绑定后面的时间会覆盖前面。
监听注册方式：addEventListener()   IE9以上支持，同一个元素同一个事件可以添加多个监听器。
eventTarget.addEventListener(type, listener[, useCapture])
type: 事件类型字符串，必定加引号，并且不带on
listener：事件处理函数
useCapture：可选参数，布尔值，默认false

2、删除事件的两种方式
1.传统注册方式eventTarget.onclick = null
2.方法监听注册方式
eventTarget.removeEventListener(type, listener[, usecapture])
divs[1].addEventListener('click', fn)
fn() {
alert(22)
divs[1].removeEventListener('click', fn)
}

3、DOM事件流
1. 三个阶段：捕获阶段、目标阶段、冒泡阶段
2.JS代码中只能执行捕获或冒泡其中的一个阶段
3.onclick 和 attachEvent(ie) 只能得到冒泡阶段
4.捕获阶段  如果addEventListener 第三个参数是true，那么则处于捕获阶段
document->html->body->father->son
5.冒泡阶段 如果addEventListener 第三个参数是false，那么则处于冒泡阶段
son->father->body->html->document
6.实际开发很少关注事件捕获，更关注事件冒泡
7.有些事件没有冒泡,比如：onblur  onfocus  onmouseover  onmouseleave

4、事件对象
div.onclick = function(event) {
console.log(event)
conslole.log(window.event)
event = event || window.event
}
1. event 就是一个事件对象 写在侦听函数的小括号里面，当形参来看
2.事件对象只有有了事件才存在，它是系统自动创建的，不需要传递参数
3.事件对象是事件一系列数据的相关集合，比如鼠标点击的坐标和事件的信息比如按下的哪个键
4.事件对象可以自己命名，如：e
5.事件对象也有兼容性问题，Ie678 通过window.event

5、常见事件对象的属性和方法
1、e.target 返回的是触发事件的对象（元素），this返回的是绑定事件的对象（元素）
2、e.type 返回事件的类型
3、e.preventDefault() 该方法阻止默认事件，比如不让链接跳转
a.document.querySelect('a')
a.addEventListener('click', function(e) {
e.preventDefault()
e.returnValue; // 低版本浏览器
return false // 传统的注册方式
})
4、e.stopPropagation() 阻止冒泡
son.addEventListener('click', function(e) {
e.propagation() // 也有兼容性问题
e.cancelBubble = true  // IE678
}) 

6、事件委托
原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在父节点上，然后利用冒泡原理影响设置每个子节点。
事件委托的作用：只操作了一个DOM，提高了程序的性能。

7、禁止选中文字和右键菜单
1.contextmenu  禁用右键菜单
document.addEventListener('contextmenu', function(e) {
e.preventDefault()
})
2.selectstart  禁止鼠标选中
document.addEventListener('selectstart', function(e) {
e.preventDefault()
})

8、鼠标事件对象和键盘事件对象
1.获得鼠标在事件中的坐标
e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标
e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标
e.pageX 返回鼠标相对于文档页面的X坐标 IE9+支持
e.pageY 返回鼠标相对于文档页面的Y坐标 IE9+支持
e.screenX 返回鼠标相对于电脑屏幕的X坐标
e.screenY 返回鼠标相对于电脑屏幕的Y坐标

9、跟随鼠标移动的小天使
1.鼠标不断移动使用使用mousemove，在页面中给document注册事件，图片绝对定位，
核心原理把最新的鼠标坐标设为图片的x 和 y
document.addEventListener('mousemove', function(e) {
let x = e.pageX
let y = e.pageY
pic.style.left = x - 50 + 'px'
pic.style.top = x - 40 + 'px'
})

10、常用的键盘事件
onkeyup 键盘被松开时触发
onkeydown  键盘按键按下时触发
onkeypress 键盘按键被按下时触发 不识别功能键ctrl shift ，区分大小写
1.事件执行顺序  onkeydown -> onkeypress -> onkeyup
2.如果使用addEventListener 不需要加on

11、keyCode判断用户按下的那个键
e.keyCode

十二、BOM浏览器对象模型
1、window对象是浏览器的顶级对象。是js访问浏览器的一个接口。
2、窗口加载事件，等页面内容全部加载完毕之后，才会触发的事件
window.onload = function() {} 或者
window.addEventListener("load", function() {})
3、DOMContentLoaded事件，仅当DOM加载完成，不包括样式表、图片，flash等
document.addEventListener('DOMContentloaded', function() {
alert(33)
})
4、调整窗口大小事件
window.onresize = function() {}
window.addEventListener("resize", function() {})
1.只要窗口大小发生像素变化，就会触发这个事件，window.innerwidth当前屏幕的宽度
5、两种定时器：1秒 = 1000毫秒
1.window.setTimeout(调用函数，[延迟的毫秒数])，在定时器到期后执行调用函数
1.window可以省略，可以直接写函数名。经常给定时器加标识符
let time1 = setTimeout(callback, 2000) 
回调函数：上一件事干完，再回头调用这个函数
2.停止定时器
window.clearTimeout(timeoutID定时器的名字) window可以省略
setInterval()
2.window.setInterval(回调函数，[间隔的毫秒数])，每隔这个时间，重复调用一次回调函数
1.window可以省略，可以直接写函数名。经常给定时器加标识符
2.清除定时器
window.clearInterval(intervalID) window可以省略，参数是定时器的标识符
6、JS的同步和异步
同步；前一个任务结束后再执行后一个任务
异步：一件事情花费很长时间，同时处理其他事情
同步任务：主线程执行线
异步任务：事件、加载、定时器添加到消息队列
同步任务执行完，再执行异步任务

7、location 对象
location.href 获取整个URL
location.host 返回域名
location.post 返回端口号
location.pathname 返回路径
location.search 返回参数
location.hash 返回#后面内容  链接

8、设置链接
location.href = 'http.baidu.com'

5秒钟自动跳转页面

9、location的方法
location.assign()  重定向页面实现跳转，可以回退
location.replace()  页面跳转，不能回退
location.reload()  页面刷新，参数为true时，强制刷新。

10、navigator 对象，包含浏览器对象的相关信息，常用的是userAgent

11、history对象
back()  后退功能
forward()  前进
go(参数)   1前进  -1后退


12、offset偏移量
offsetParent  	返回带有定位的父元素，没有就是Body
offsetTop  返回相对有定位的父元素上方的偏移
offsetLeft  返回相对有定位的父元素左方的偏移
offsetWidth  返回元素的大小，宽度，包括padding,border
offsetHeight  返回元素的大小，高度，包括padding,border

13、offset 与 style 区别
offset可以得到任意样式表中的样式值，获取的数值没有单位，都是只读不能赋值，包含padding + border + width
style只能得到行内样式的值，style.width 获得的是带有单位的字符串，只获得width，style.width可读写，要想给元素更改值，需要style来改变

14、clientHeight 不含边框，内容区的高度，返回数值不带单位
clientWidth  不含边框，内容区的宽度，返回数值不带单位
clientTop  返回元素上边框的大小
clientLeft  返回左边框大小

15、立即执行函数，不需要调用，立马能够执行
  (function () {})()  或者  (function (){}())  第二个小括号可以看做是调用函数
立即执行函数独立创建了一个作用域，都是局部变量，不会冲突。

16、页面尺寸大小发生变化的时候，resize
        pageShow  重新加载页面触发的事件

17、scroll 系列的属性可以动态得到该元素的大小、滚动距离
scrollTop  返回被卷去的上测距离
scrollLeft  返回被卷去的左测距离
scrollWidth  返回元素实际宽度 不含边框，不带单位
scrollHeight  返回元素实际高度 不含边框，不带单位

onscroll事件

相对于页面 pageXOffset   pageYOffset  ie9以上支持

18、三大系列主要用途
1、offset系列主要用于获取元素的位置
offsetLeft、offseTop
2、client 经常用于获取元素大小
clientWidth、clientHeight
3、scroll经常用于获取滚动距离
scrollTop、scrollLeft
4、页面的滚动距离window.pageXOffset

19、mouseenter事件和mouseover事件
mouseover经过父盒子和子盒子都会触发，会多次触发
mouseenter 只有经过自身盒子触发，不会冒泡

十三、本地存储
1、window.sessionStorage 生命周期为关闭浏览器窗口，同一个页面数据可以共享，以键值对的形式存储使用
存储数据：sessionStorage.setItem(key, value)
获取数据：sessionStorage.getItem(key)
删除数据：sessionStorage.removeItem(key)
删除所有数据：sessionStorage.clear()

2、window.localStorage  生命周期永久生效，除非手动删除否则关闭页面也会存在，可以多个页面共享（同一浏览器）以键值对的形式存储。
存储数据：localStorage.setItem(key, value)
获取数据：localStorage.getItem(key)
删除数据：localStorage.removeItem(key)
删除所有数据：localStorage.clear()

十四、ECharts使用五部曲
1、下载echarts.js文件
2、准备一个具备大小的DOM容器
<div style="width:500px; height: 500px;"></div>
3、初始化echarts实例对象
 echarts.init(document.getElementById('main'))
4、指定配置项和数据
var option = {
5、将配置项设置给echarts实例对象
myChart.setOption(option)
6、配置项手册
title：标题组件
tooltip：提示框组件
legend：图例组件
toolbox：工具栏
grid：直角坐标系内绘图网格
xAxis：直角坐标系gird中的x轴
yAxis：直角坐标系grid中的y轴
series：系列列表，每个系列通过type决定自己的图表类型
color：调色盘颜色列表

7、series 系列列表
type：类型（line 是折线，bar是柱形）
name: 系列名称，用于tooltip显示，legend的图例筛选变化
stack：数据堆叠，如果设置相同值则会数据堆叠，如果指定不同值，或者去掉这个属性则不会堆叠。
radius: ['10%',  '70%']  // 饼图半径，第一个是内半径，第二个是外半径，实现饼图大小
center: ['50%', '50%']   //  图表中心位置left50% top50% 距离图表DOM容器
roseType: 'radius'   //  radius 是半径模式，另外一种是area 面积模式
 
8、tooltip: {   //  提示框组件
trigger:  'item'  //  触发方式，item意思是放到数据对应图形上触发提示
//  格式化提示内容
//  a 代表series系列图表名称
//  b 代表series数据名称data里面的name
//  c 代表series数据值data里面的value
//  d 代表当前数据/总数据的比例
formatter: '{a}  <br/>{b} : {c} ({d}%)'
}

十五、XMLHttpRequest 基于xml发起的请求(原生)
1、请求参数的本质是查询字符串
2、URL编码：原则使用安全的字符表示不安全的字符，使用英文字符表示非英文的字符。
URL编码函数：encodeURIComponent()
URL解码函数：decodeURIComponent()
3、数据交换的格式：服务器端与客户端之间进行数据传输与交换的格式。主要是XML和JSON格式（主要）
4、JSON是javaScript数组和对象的字符串表示法，本质是字符串，是一种轻量级的数据交换格式，更小，更快，更易解析。
数据类型是数字、字符串、布尔值、null、数组、对象
属性名必须双引号包裹，字符串类型必须双引号，不能写注释，最外层必须是对象或者数组，不能使用undefined或者函数作为JSON的值
JSON和JS对象的关系：JSON是JS对象的字符串表示法
JSON字符串转JS对象叫反序列化：JSON.parse()，JSON反序列化
JS对象转JSON字符串叫序列化：JSON.stringify()，JSON序列化
5、FormData对象管理表单数据
//  新建FormData对象
var fd = new FormData()
// 为 FormData新增表单项
fd.append('uname',  'wangyufan')
fd.append('age',  18)

十三、axios
1、Axios 是专注于网络数据请求的库，简单易用，轻量化
axios.get('url', {params: {/*参数*/}}).then(function() {})
axios.post('url',  {/*参数*/}).then(function() {})
直接使用axios发起请求
axios({
method: '请求类型',
url: '',
data: {/*POST数据*/},
params: {/*GET参数*/}
}).then(callback)

十四、同源策略和跨域
1.什么是同源：协议、域名、端口号相同，反之跨域；
2.同源策略：浏览器提供的安全功能，A网站的JavaScript，不允许和非同源的网站C之间，进行资源交互，		
例如：无法读取非同源网站的Cookie、LocalStorage 和 indexedDB，无法接触非同源网站的DOM，无法向非同源地址发送ajax请求
3.如何实现跨域数据请求：JSONP 和 CORS
JSONP:兼容性好，只支持GET请求，不支持POST请求
CORS:是W3C标准，支持GET和POST请求，不兼容低版本浏览器
JSONP的实现原理：<script>标签通过src属性，请求非同源的js脚本
4、防抖策略：当事件被触发后，延迟n秒再执行回调，如果在这n秒内事件又被触发，则重新计时。
好处：有效减少请求次数，节约请求资源。应用：输入框搜索
如何防抖：定义防抖函数中定义定时器，在事件中先清除定时器再打开定时器。
5、节流：减少一段时间内事件的触发频率。应用场景：鼠标连续不断的触发某事件，只在单位时间内触发一次。
节流阀：空可以执行下次操作，不为空，则不执行下次操作。当前操作完，将节流阀重置为空。每次操作前先判断节流阀是否为空。
应用：定义一个节流阀，通过定位器给节流阀赋值，每次操作完成后清空节流阀。
防抖和节流的区别：防抖：如果事件被频繁触发，防抖可以保证只有一次生效，节流：如果事件被频繁触发，节流能减少事件触发的频率，节流是有选择性的执行一部分事件。

十五、HTTP协议简介
1、通信：信息的传递与交换。通信三要素：通信的主体、内容和方式；
2、通信协议HTTP协议：客户端与服务器实现网页内容的传输，遵守网页内容的传输协议。
3、http协议的交互模型：采用了请求/响应的交互模型。
客户端发起的请求叫HTTP请求，客户端发送到服务器的消息叫HTTP请求消息也叫HTTP请求报文。
HTTP请求消息由请求行、请求头部、空行和请求体4个部分组成
请求行由请求方式、URL和HTTP协议版本组成，之间用空格隔开
请求头部用来描述客户端的基本信息，从而把客户端的相关信息告知给服务器，如：
user-Agent  用来说明当时是什么类型的浏览器
content-Type  用来描述发送到服务器的数据格式
Accept  用来描述客户端能够接受什么类型的返回内容
Accept-Language 用来描述客户端期望接受哪种人类语言
请求头部由多行键值对组成，每行的键和值由冒号分隔
空行，分隔请求头和请求体，只有POST请求才有请求体，GET请求没有请求体

响应消息是服务器响应给客户端的消息内容，也叫响应报文。
HTTP响应消息由状态行、响应头部、空行和响应体4个部分组成
状态行由HTTP协议版本、状态码和状态码的文本描述3个部分组成，使用空格隔开
响应头部用来描述服务器的基本信息，响应头部由多行键值对组成，每行的键值用英文的冒号分隔
空行用来分隔响应头部和响应体
响应体中存放的是服务器响应给客户端资源内容，看response

4、HTTP请求方法，用来表明要对服务器上的资源执行的操作，最常用的请求方法是GET和POST
GET：向服务器要资源（查询）
POST：向服务器提交资源，提交表单和上传文件（新增），数据包含在请求体中提交给服务器
PUT：提交资源，并使用提交的新资源替换旧资源（修改）
DELETE：请求服务器删除指定资源（删除）

5、HTTP响应状态码，用来标识响应的状态
HTTP响应状态码的组成及分类
1**   信息  
2**  成功
3**  重定向，需要进一步的操作以完成请求
4**  客户端错误
5**  服务器错误

十六、GIT的基础概念
1、SVN差异比较：基于差异的版本控制，好处：节省磁盘空间，缺点：耗时，效率低
2、GIT快照：在原有的文件版本基础上重新生成一份文件，类似于备份，优点：版本切换的非常快，缺点：占用磁盘空间大，特点：空间换时间，GIT几乎所有的操作都是在本地执行，只需要访问本地文件和资源，
3、GIT管理的项目有三个区域：工作区、暂存区、GIT仓库
GIT的三种状态：已修改modified(还没放到暂存区)、已暂存staged（放入暂存区）、已提交committed（保存着特定版本）
4、安装完Git之后
1、设置自己的用户名和邮件地址
git config --global user.name "wangyufan"
git config --global user.email "1339433040@qq.com"
--global 只需要运行一次，就永久生效
2、查看git所有全局配置项
git config --list --global
3、获取帮助信息 git config -h快速参考 或git help config 无需联网打开帮助手册
4、获取git仓库的两种方式
将尚未进行版本控制的本地目录转换为GIT仓库
1.鼠标右键打开git Bash
2.git init 将当前目录转化为git仓库
3.工作区文件的4种状态
未被git管理：未跟踪（untracked） 一般新建的文件
已被Git管理：未修改、已修改、已暂存
4.git status 查看文件处于什么状态，精简输出  git status -s
5.git add index.html 开始跟踪一个文件  添加多个文件git add .
6.git commit -m '提交的消息'  将文件提交到仓库中进行保存
7.从暂存区中移除某个文件 git reset HEAD 要移除的文件名称
git reset HEAD . 移除所有
8.git commit -a -m '描述'   跳过暂存区直接提交到仓库
9.查看历史  git log 
10.在一行展示所有提交历史
git log --pretty=oneline
根据指定ID回退到指定版本
git reset --hard ID
在旧版本中查看历史
git reflog --pretty=oneline
再次根据最新的ID提交到最新版本
git reset --hard ID
在未add之前stash
git stash [save message保存，save为可选项，message为本次保存的注释

git stash list 查看所有保存的记录列表

git stash pop stash@{num}  只能恢复一次

git stash apply stash@{num} 可回复多次
git stash drop stash@{num} 删除某个保存，

git stash clear 删除所有保存



从其他服务器克隆一个已存在的仓库

十六、开源项目管理平台
1、git push -u origin master  第一次推送到远程仓库
2、本地分支操作  基本基于master分支创建新分支
1.查看分支列表  
 git branch
2.基于当前分支，创建新分支，新分支代码与当前分支完全一样，创建完成还是处于当前分支
git branch 分支名称
3.切换指定分支 
 git checkout 分支名称
4.创建新分支并立即切换到新分支  
git checkout -b 分支名称
5. 合并分支
1.  切换到主分支  git checkout master
2.  在master 分支上运行 git merge命令，将login分支的代码合并到主分支   git  merge login
6、删除分支，删除时不处于这个分支
git branch -d 分支名称
7、遇到冲突时的分支合并，在reg分支和master分支同时修改同一个文件时，在主分支上进行合并。
git checkout master
git merge reg   （此时发生冲突）
打开包含冲突的文件，手动解决冲突之后
git add .
git commit -m '解决了合并冲突的问题'

8、将本地分支推送到远程仓库
-u  表示第一推送将本地分支与远程分支关联
git push -u 远程仓库别名 本地分支名称：远程分支名称
例：git push -u origin payment:pay
如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化
git push -u origin payment

9、查看远程仓库中所有的分支列表
git remote show 远程仓库名称

10、跟踪分支：从远程仓库中把远程分支下载到本地仓库
git checkout 远程分支的名称
例：git checkout pay
从远程仓库中，把对应得远程分支下载到本地仓库，并把下载的本地分支进行重命名
git checkout -b 本地分支名称 远程仓库名称/远程分支名称
例：git checkout -b payment origin/pay

11、拉去远程分支最新的代码
git pull 
12、删除远程分支
删除远程仓库中，指定名称的远程分支
git push 远程仓库名称 --delete 远程仓库分支名称
例：git push origin --delete pay
git branch -D reg  不管是否合并都强制删除本地分支


十七、包管理工具
1. 执行npm i 一次性安装所有的包
2.使用cors中间件解决跨域问题
npm i cors 
const cors = require('cors')  //  在路由之前导入
app.use(cors())  //  配置中间件

十八、vue概述
1.vue渐进javaScript框架：声明式渲染->组件系统->客户端路由->集中式状态管理->项目构建
2.基本使用
      vue 的基本使用步骤
        1. 需要提供标签填充数据
        2.引入vue.js库文件
        3.可以使用vue的语法做功能了
        4.把vue提供的数据填充到标签里面

    	el  元素的挂载位置（CSS选择器或DOM元素）
     	data:  模型数据（值是一个对象）

{{}} 插值表达式，将数据填充到html标签中，支持基本计算操作

原理：编译过程（vue语法->原生语法）
3.模板语法概览
插值表达式
指令
事件绑定
属性绑定
样式绑定
分支循环结构

4、指令：本质是自定义属性，格式以v-开始
1.v-cloak  插值表达式存在闪动，使用v-vloak，原理先隐藏，替换好值后再显示最终的值
2.数据绑定指令：
v-text  填充纯文本  相比插值更简洁
v-html  填充html片段，存在安全问题，本网站数据可以使用，第三方的数据不可以用
v-pre  显示原始信息，跳过编译过程
3.数据响应式
响应式：1.H5中的响应式（屏幕尺寸变化导致样式变化）2.数据响应式（数据的变化导致页面内容的变化）	
数据绑定：将数据填充到标签中
v-once：只编译一次，显示内容之后不再具有响应式的功能

4.双向数据绑定
v-model='' 页面内容改变数据，数据也改变页面内容，主要用于表单输入
MVVM设计思想：
M（model）：data, plain JavaScript Object
V（view）：DOM
VM（View-Model）vue（DOM listeners(v->M)  Data bindings(M->v)）

5.事件绑定
1.v-on:click='num++'  简写  @click='num++'
2.事件函数的调用方式
1.直接绑定函数名称： @click='say'
2.调用函数： @click='say()'
3.事件函数参数传递（普通参数， 事件对象）
v-on:click='say('hi', $event)'
1.如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数
2.如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，并且事件对象的名称必须是$event
4.事件修饰符
.stop 阻止冒泡  v-onclick.stop="handle"
.prevent 阻止默认行为  v-onclick.prevent="handle"
5.按键修饰符
.enter 回车键   v-on:keyup.enter = 'submit'
.delete删除键   v-on:keyup.delete = 'handle'
6.自定义按键修饰符
Vue.config.keyCodes.fi = 65   //  event事件对象里面的keyCode
规则：自定义按键修饰符名字是自定义的，但是对应得值必须是按键对应得event.keyCode值
@keyup.65 = 'handle'

6.属性绑定
1.vue动态处理属性  v-bind用法  v-bind:href = 'url'
v-bind:href = 'url'   缩写  :href='url'
2. v-model 底层实现原理分析
<input v-bind:value='msg' v-on:input="msg=$event.target.value"></input>

7.样式绑定-class样式处理
1.对象语法  :class='{ active: isActive }'
对象形式通过属性值为true或false来控制属性是否显示 
2.数组语法  :class='[ activeClass,  errorClass ]'
动态样式:class 不能和行内样式style一起用

8.样式绑定-class样式的三个小细节
1.对象绑定和数组绑定可以结合使用
:class='[activeClass, errorClass, {test: isTest} ]'
.test {
color: red;
}
data: {
isTest: true;
}
2.class绑定的值可以简化操作
简化数组形式
:class='arrClasses'
.active {
color: red;
}
another {
border: 1px solid red;
}
data: {
arrClasses: ['active', 'another']
}

简化对象形式
:class='objClasses'
data: {
objClasses: { active: true,  another: true }
}
3.默认的class如何处理？
class='base'  :class='arrClasses'   //  没影响


9.样式绑定-style样式处理
1.  :style = '{ color: activeColor, fontsize: fontsize }'
简化对象形式： :style = 'objStyle'
data: {
objStyle: {
border: '1px solid red',
width: '300px'
}
}

2.  :style = '[baseStyles, overridings]'  // 数组里面是两个对象形式，可以覆盖

10.分支循环结构
1. 分支结构
v-if  控制元素是否渲染到页面
v-else
v-else-if
v-show 原理控制元素样式是否显示  display: none （已经渲染到页面）
频繁显示隐藏建议v-show 性能较好

2.循环结构
v-for遍历数组
<li v-for='item in list'>{{ item }}</li>
<li v-for='(item, index) in list'>{{ item +'--'+ index }}</li>
key的作用：帮助vue区分不同的元素，从而提高性能
<li :key='item.id' v-for='(item, index) in list'>{{ item +'---'+ index }}</li>

v-for遍历对象
v-for='(value, key, index) in object'  值，键， 索引
v-if 和 v-for结合使用
v-if='value === 12' v-for='(value, key, index) in object'

11、表单域的修饰符
1. v-model.number = 'age'   转化为数值
2. trim 去掉开始和结尾的空格  v-model.trim = 'age'
3. lazy 将input 事件切换为change事件(只有当失去焦点的时候才会触发)
 v-model.lazy = 'age'

12、自定义指令
1. 为何需要自定义指令：内置指令不满足需求
2. 自定义指令语法规则（获取元素焦点）
Vue.directive('focus', {
inserted: function(el) {
el.focus()
}
})
<input type='text' v-focus></input>

3. 带参数的自定义指令（改变元素的背景颜色）
Vue.directives('color', {
inseted: function(el, binding) {}
el.style.backgroundColor = binding.value.color
})
<input type='text' v-color='{color: 'orange'}'>

4. 局部指令
directives: {
focus: {
inserted: function(el) {
 	el.focus()
}
}
}

13、计算属性
1.为何需要计算属性：可以使得模板内容更加整洁
2.计算属性的用法
conputed: {
reverseMsg: function() {
return this.msg.split(' ').reverse().join()
}
}
3.计算属性和方法的区别
计算属性基于他们的依赖进行缓存的
方法不会缓存

14、侦听器：数据一旦发生变化就通知侦听器绑定的方法。
1. 应用场景：数据变化时执行异步或开销较大的操作。

15、过滤器
1. 自定义过滤器
 	Vue.filter(' 过滤器名称 '， function(value) {
// 过滤器业务逻辑
})
2. 过滤器的使用
<div>{{ msg | upper }}</div>
<div>{{ msg | upper | lower }}</div>
<div v-bind:id = 'id | fromId '></div>
3. 局部过滤器
filters: {
captilize: function() {
return  ...
}
}
4.带参数的过滤器
Vue.filter('format', function(value, arg1) {
// value 就是过滤器传递过来的参数
})
5. 过滤器的使用
<div>{{  date | format('yyyy-mm-dd') }}</div>


16. 生命周期
1.主要阶段
挂载（初始化相关属性）
beforeCreate  在实例初始化后，数据观测（data observer）和 event/watcher 事件配置之前调用
created 在实例创建完成之后被调用，在这一步，实例已完成了以下配置：数据观测（data oberver），属性和方法的运算， watch/event事件回调 然而，挂载阶段还没开始，							   $el 属性目前不可见 
beforeMount  在挂载开始之前被调用，相关的渲染函数首次被调用
mounted  el 被新创建的 vm.$el替换，挂载成功
更新（元素或组件的变更操作）
beforeUpdate  数据更新时调用
updated  组件 DOM 已经更新，组件更新完毕
销毁 （销毁相关属性）
beforeDestroy  实例销毁之前调用
destroyed  实例销毁之后调用

17、案例
1.修改响应式数据  vm.$set(数组名称，索引， 值) 或者 vm.$set(对象，属性，属性值)
2.去掉a标签的默认闪动@click.prevent
3.mounted 该生命周期钩子函数被触发的时候，模板已经可以使用，此时用于获取后台数据，然后把数据填充到模板。

18、全局组件注册语法
1. Vue.component(组件名称，{
data: 组件数据，
template: 组件模板内容
})
2. 组件注册注意事项
1.data必须是一个函数
2.组件模板内容必须是单个根元素
3.组件模板内容可以是模板字符串
4.组件命名方式短横线或驼峰，在根组件使用时转化为短横线

19、组件局部注册
1. var componentA = {
data: 数据
template: 模板
}
new Vue({
el: '#app',
components: {
'component-a': componentA
}
})
2.局部组件注册只能在注册他的父组件中使用

20、父组件向子组件传值
1. 组件内部通过props接受传递过来的值
Vue.component('menu-item', {
props: [' title '],
template: '<div>{{ title }}</div>'
})

2.父组件通过属性将值传递给子组件
<menu-item :title='title'></menu-item>

3.props属性名规则 在props中用驼峰，模板中使用短横线，字符串模板中没有限制

4.props属性值类型
字符串String  数值 Number  布尔值 Boolean 数组 Array 对象 Object

21、子组件向父组件传值
1.props传递数据原则：单向数据流
2.子组件通过自定义事件向父组件传递信息
<button @click='$emit("enlarge-text")'></button>
3.父组件监听子组件的事件
<menu-item @enlarge-text='fontSize += 0.1'></menu-item>
4.注意：emit里面的自定义事件只能是短横线

5. 子组件向父组件传递参数
<button @click='$emit(' enlarge-text ', 5)'></button>
6.父组件监听子组件的事件
<menu-item  @enlarge-text='fontSize +=  $event'></menu-item>

22、兄弟组件之间的通信
1. 单独的事件中心
var eventHub = new Vue()
2.监听事件与销毁事件
eventHub.$on('add-todo',  addTodo)
eventHub.$off('add-todo')
3.触发事件
eventHub.$emit('add-todo',  id)

23、组件插槽基本用法
1.插槽位置  注意：子组件只有一个根元素
Vue.component('aler-slot', {
template: '
<div>
<span>Error!</span>
<slot></slot>
</div>
'
})
2.插槽内容
<aler-slot>hello hi  yufan</aler-slot>

24、具名插槽
1.插槽定义
<div class="container">
<header>
<slot name="header"></slot>
</header>
<main>
<slot></slot>
</main>
<footer>
<slot name="footer"></slot>
</footer>
</div>

2.插槽内容
<base-layout>
<h1 slot='header'></h1>
<p>主要内容</p>
<p slot="footer">底部内容</p>
</base-layout>

25、作用域插槽：父组件获取子组件的数据并进行加工处理
1. 插槽定义
<ul>
<li v-for='item in List'  :key="item.id">
<slot :item='item'>
{{ item.name }}
</slot>
</li>
</ul>

2. 插槽内容
<fruit-list :list='list'>
<template slot-scope='slotProps'>
<strong v-if='slotProps.item.current'>{{ slotProps.item.name }}</strong>
</template>
</fruit-list>

27、路由的基本概念和原理
1. 后端路由：根据不同的用户URL请求，返回不同的内容。本质：URL请求地址与服务器资源之间的对应关系。存在性能问题。
2. 前端路由：根据不同的用户事件，显示不同的页面内容，本质：用户事件与事件处理函数之间的对应关系。

28、Vue-router基本使用
1. 基本使用步骤
1.引入相关的库文件
<script type="text/javascript" src="./vue-router.js"></script>
2.添加路由链接
<router-link to="/user">User</router-link>
router-link 是vue中提供的标签，默认会被渲染为a标签
to属性会被渲染为href属性
to属性的值会被渲染为#开头的hash地址
3.添加路由填充位(也叫路由占位符)
通过路由规则匹配到的组件，将会被渲染到router-view所在的位置
<router-view></router-view>
4.定义路由组件
var  user  =  {
template: '<div>user</div>'
}
var register = {
template: '<div>register</div>'
}
5.配置路由并创建路由实例
// 创建路由实例对象
var router = new VueRouter({
// routes 是路由规则数组
routes: [
// 每个路由规则都是一个配置对象，至少包含path和component两个属性
// path表示当前路由规则匹配的hash地址
// component 表示当前路由规则对应要展示的组件
{path: '/user', component: User},
{path: '/register', component: Register}
]
})
6.把路由挂载到Vue根实例中
new Vue({
el: '#app',
// 为了能够让路由规则生效，必须把路由对象挂载到vue实例对象上
router
})

2.路由重定向
指的是：用户A访问地址A的时候，强制用户跳转到地址C，从而展示特定的组件页面；
通过路由规则的redirect属性，指定一个新的路由地址，可以很方便的设置路由重定向。
var router = new VueRouter({
routes: [
// 其中，path表示需要被重定向的原地址，redirect 表示将要被重定向的新地址
{path: '/',  redirect: '/user'},
{path: '/', component: 'User'},
{path: '/', component: 'Register'}
]
})

3.嵌套路由：点击父级路由链接显示模板内容，模板内容又有自己路由链接，点击子级路由链接显示子级模板内容。
1. 父路由组件模板
父路由链接，父路由填充位
<p>
<router-link to='/user'>user</router-link>
<router-link to='/register'>register</router-link>
</p>
<div>
//  路由占位符
<router-view></router-view>
</div>

2. 子级路由模板
子路由链接、子路由填充位
const register = {
template: '
<div>
<h3>register  组件</h3>
<router-link to='/register/tab1'>tab1</router-link>
<router-link to='/register/tab2'>tab2</router-link>

//  子路由填充位
<router-view/>
</div>
'
}

3.父级路由通过children属性配置子级路由
const router = new VueRouter({
routes: [
{ path: '/user', component: User },
{
path: '/register',
component: Register,
// 通过children属性，为/register 添加子路由规则
children: [
{ path: '/register/tab1', component: tab1 },
{ path: '/register/tab2', component: tab2 }
]
}
]
})


