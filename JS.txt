一、变量
1、变量：在内存中开辟空间用来存放数据；
2、只声明，不赋值： undefoned；不声明，不赋值：报错；不声明，只赋值：正常；
3、声明变量并赋值：变量初始化；
4、变量的命名规范：变量名必须有意义；
5、交换两个变量： 用一个中间变量来赋值。

二、数据类型
1、JS的变量数据类型是：
1)只有在程序运行的过程中，根据等号右边的值来确定的。 
eg: var num = 10  // 数值型； var str = 'pink'; // 字符串型
2)JS拥有动态类型，同时也意味着相同的变量可用作不同的类型
eg: var x = 3; // x为数字  var x = 'all' // x为字符串

2、数据类型的分类
JS把数据类型分为两类：
简单数据类型：Number、String、Boolean、Underfined、Null
复杂数据类型：Object

1）简单数据类型：
1.Number 分整型和小数型；
JS中八进制前面加0，十六进制前面加0x；
isNaN() 判断非数字 是返回false,不是返回true；
2.字符串型
1)String推荐使用单引号；'String'
2)字符串转义符用 \ 开头，但是这些转义符要写到引号里面去
\n 换行;  \ \  斜杠\ ;  \'  '单引号; \* *双引号;  \t tab缩进;  \xa0  空格
3)字符串长度通过length属性可以获取整个字符串的长度
eg: str.length
4)字符串拼接 
字符串 + 任意类型 都是字符串 
数值相加，字符相连，引引加加
变量不能加引号，加引号就变成字符串
5）布尔型Boolean
参与加法运算
undefined + 数字 = undefined
null + 1 = 1
6）获取检测变量数据类型 typeof num
7)  字面量：表示如何表达这个值
数字字面量：8 9 10
字符串字面量： ‘哈哈哈’
布尔字面量：true, false
8)  数据类型的转换
1.转换为字符串：
toString()  num.toString()
String()  String( num )
加号拼接字符串 + ' '
2.转换为数字型***
parseInt( age )  取整，会去掉小数点和单位
parseFloat( 3.14 )
Number( '12' )
利用- * /  eg: '12' - 0
3.转换为布尔型
Boolean() 函数
 ' ', 0, NaN, null, undefined代表空、否定的值会被转换成false
其余转换为true；

扩展
1、JS属于解释性语言；
2、标识符、关键字、保留字：
标识符：为变量、属性、函数、参数取的名字。不能是关键字、保留字

三、运算符
1、算术运算符：+ — * / %取余，浮点数算术运算有问题
不要直接判断两个浮点数是否相等
取余主要用来判断是否整除，余数为0
2、表达式：由数字、运算符和变量组成的式子；最终返回一个结果返回值；
把右边的值赋值给左边：var num = 1 + 1
3、递增( ++ )和递减( -- )
1) 前置递增：++num  先自加，后返回值
2) 后置递增：num++  先返回原值，后自加1
4、比较运算符：返回的是一个布尔值（true / false）作为运算的结果
==  会转型  18 == ‘ 18 ’  // true  会把字符串型的转换为数字型
===  !==  全等 要求值和类型完全一样
5、逻辑运算符：进行布尔值运算，返回的也是布尔值，用于多个条件判断
&&    ||    !
短路运算：当有多个表达式（值）时，左边的表达式可以确定就不看右边
表达式1 &&  表达式2  如果1为真，则返回2；如果1为假，则返回1 
eg: 123 && 456   // 456
如果有空的或者否定的为假，其余是真的；0  ' ' undefined  null NaN

表达式1 ||  表达式2  如果1为真，则返回1；如果1为假，则返回2
eg: 123 || 456   //  123
6、赋值运算符：把数据赋给变量 +=  -=  *=
num = num + 1  // num++
num = num + 2  // num += 2
7、运算符优先级
小括号 ()  
一元运算符 ++  --  !	
算术运算符 * / + -
关系运算符  > >= < <=   返回true 或false
相等运算符 ==  !==  === !==
逻辑运算符  &&  || 
赋值运算符 =
逗号运算符 ，
一元运算符里面的逻辑非优先级很高
逻辑与比逻辑或优先级高

四、JS流程控制
1、顺序结构
2、分支结构：根据不同条件、执行不同的路径代码（多选一）
，得到不同的结果
if  //  如果if表达式条件为真，则执行花括号里面的语句
//  如果if条件表达式为假，则不执行花括号里面的代码，
执行if 后面语句的代码
if ( 条件表达式 ) {
// 执行语句
}

// 如果if表达式条件为真，则执行花括号里面的语句1; 
否则执行语句2；最终只能有一个语句执行；
if （条件表达式）{
// 执行语句1
} else {
// 执行语句2
}

if else if 多分支语句
if （条件表达式1）{
// 语句1
} else if （条件表达式2）{
// 语句2
} else if （ 条件表达式3）{
//语句3
} else {
//最后的语句
}
3、三元表达式：由三元运算符组成的式子
条件表达式 ？表达式1 ： 表达式2
//  如果条件表达式结果为真 则返回表达式1，如果条件表达式为假
，则返回表达式2的值。
var num = 10
var result = num > 5 ? '是的' : '不是的'  // 表达式有返回值
4、switch 语句：针对变量设置一系列的特定值的选项
switch 转换、开关  case 小例子或者选项的意思
switch(表达式) {  
case value1:
执行语句1；
break;
case value2:
执行语句2；
break;
...
default:
执行最后的语句；
}
思路：利用表达式的值 和 case后面的选项值相匹配，如果匹配上
就执行该case里面的语句，如果没有匹配上，那么执行default里面
的语句。
**开发时经常把表达式写成变量
**变量的值和case里面的值相匹配的时候是全等，是值和数据类型
一致才可以。
**break  如果当前的case里面没有break，则不退出switch是继续
执行下一个case.
5、switch 和 if else if 语句的区别
①一般情况可以互换；
②switch...case 处理case为确定值的情况；而if..else..用于范围判断
（大于或等于某个范围）
③switch进行条件判断后直接执行到条件语句，效率更高；
而if..else..语句有几种条件，就得多判断几次。
④当分支比较少时，if..else..效率更高
⑤当分支比较多时，switch执行的效率更高

6、循环的目的：可以重复执行某些代码
三种循环语句： for循环； while 循环；do...while..循环
 循环体：一组被重复执行的语句称为循环体。
for ( 初始化变量；条件表达式；操作表达式 ) {
//  循环体
}
for 循环执行相同的代码
for 循环执行不同的代码
for ( var i=1; i<=100; i++ ) {
console.log( i )
}
for 循环重复某些相同的操作
for 循环重复某些不同的操作

双重for循环：语法结构
for (外层初始化变量；外层条件表达式；外层操作表达式) {
for(里层初始化变量；里层条件表达式；里层操作表达式) {
执行语句
}
}
外层循环执行一次，里面的循环执行全部

当条件表达式为true，则执行循环体；否则退出循环；
while (条件表达式) {
// 循环体
操作表达式
}
先执行循环体，再判断条件
do {
// 循环体
} while (条件表达式)

continue 关键字：用于立即跳出当前次循环，继续下一次循环
break关键字：用于立即跳出整个循环

命名规范：
变量、函数的命名必须要有意义
变量名称一般是名词
函数名称一般是动词
操作符的左右两侧各保留一个空格

单行注释规范
单行注释前面注意有个空格
小括号前后有空格

五、数组：是指一组数据的集合，其中每个数据称作元素，在数组中可以存
放任意类型的元素，数组是一组数据存储在单个变量名下的优雅方式。
1、创建数组
利用new创建数组；
var arr = new Array();  // 创建一个新的空数组
利用数组字面量创建数组；
var arr = [ ]
数组里面的数据用逗号分隔；
数组的字面量是方括号[ ]
声明数组并赋值称为数组的初始化
2、获取数组中的元素 格式  数组名[索引号]
数组的索引（下标从0开始）	
3、遍历数组：把数组元素从头到尾访问一次
数组的长度是元素个数arr.length动态监测数组元素个数
4、数组中新增元素
1.通过修改length长度新增数组元素;
2.通过修改数组索引新增数组元素
不要直接给数组名赋值，否则里面的元素都没有
筛选数组（去重）、翻转数组、冒泡排序

六、函数：就是封装了一段可以被重复执行调用的代码块，
目的：就是让大量代码重复使用。
1.函数使用：声明函数
function 函数名() {  // 形参默认为undefined
// 函数体
}
函数不调用，自己不执行
2.调用函数：函数名()
3.形参和实参：
function 函数名(形参1，形参2...) {  // 形式上的参数

}
函数名(实参1， 实参2....)  //  实际的参数
形参是接收实参的
4.形参和实参个数匹配；// 尽量匹配
1.形参与实参个数一致，则正常输出；
2.如果实参个数多于形参，会取到形参个数；
3.如果实参个数小于形参个数，NaN
形参可以看做是没有声明的变量；
函数可以带参数也可以不带参数；
5.函数的返回值
1.return 语句
function 函数名 () {
return 需要返回的结果；
}
函数名();
函数只是实现某种功能，最终的结果需要返回给函数的调用者
函数名() ，通过return语句来实现的
只要函数遇到return 就把后面的结果返回给函数的调用者
函数名() =  return 后面的结果
6.return 终止函数
return 语句之后的代码不被执行；一次只能返回一个值，
如果有多个值，逗号隔开，以最后一个为准；
可以返回一个数组；
函数有return，返回的是return后面的值；
没有return,则返回的是Undefined；
return 不仅可以退出循环，还可以返回return语句中的值，
同时还可以结束当前函数体的代码；
7. arguments 的使用
是当前函数的内置对象，存储了传递的所有实参；
伪数组：
1.具有length属性；
2.按照索引的方式进行存储；
3.它没有真正数组的一些方法；
4.可以按照数组的方式遍历arguments；
8.利用函数封装翻转数组
1. 单层循环  arr.length-1 ；新数组盛放；
冒泡排序
1.双层循环：趟数arr.length-1
交换的此时：arr.length-i-1
两个变量交换
9.函数可以调用另外一种函数
10.函数的两种声明方式：
1.利用函数关键字定义函数
function fn() {

}
2.函数表达式(匿名函数	)
var 变量名 = function() {};
var fun = function() {
console.log('我是函数表达式')
}
fun()
1)fun是变量名，不是函数名
2)函数表达式声明方式跟声明变量差不多，只不过变量里面
存的是值，而函数表达式里面存的是函数；
3)函数表达式可以进行参数传递

七、作用域：可用性代码范围，减少命名冲突；
全局作用域：整个script标签
局部作用域：在函数内部起作用和效果；
块级作用域 { }
变量作用域：全局变量和局部变量
全局变量： 在全局作用域下的变量，占内存
在函数内部没有声明直接赋值的变量也是全局变量
局部变量：只在函数内部使用，节约内存
函数的形参也可以看做局部变量
作用域链：
内部函数可以访问外部函数变量，链式一层一层查找
哪些函数可以被访问。

八、预解析
js引擎：预解析、代码执行
把var  function提升到当前作用域的最前面；
变量预解析（变量提升）
变量声明提升，赋值不提升	
函数预解析（函数提升）
函数声明提升，不调用函数	

九、对象：一个具体的事物
对象是一组无序的相关属性和方法的集合。
属性：事物的特征；
方法：事物的行为；
1.创建对象的三种方式
字面量、new Object 、构造函数
1)利用字面量创建对象
var obj = { }  // 创建了一个空对象
var obj = {
uname: '张三';
age: 16,
sayHi: function() {
console.log('hi~')
}
}
// 里面的属性和方法采取键值对；键 属性名 ：值  属性值
// 多个属性或者方法中间用逗号分隔
// 方法冒号后面跟一个匿名函数
2.调用对象的属性
对象名.属性名 obj.uname
对象名[ '属性名' ]
3.调用对象的方法 
对象名.方法名()    //  obj.sayHi()
4.变量、属性、函数、方法的区别
相同点：变量和属性都是用来存储数据的。
不同点：变量单独声明并赋值，使用时直接写变量名，单独存在；
   属性在对象里面，不需要声明，使用时对象.属性名
函数和方法
相同点：都是实现某种功能；
不同点：函数是单独声明并调用，函数名()  单独存在
   方法在对象里面	调用的时候 对象.方法名()

2) 利用new Object 创建对象
var obj = new Object()  // 创建了一个空对象
obj.uname = '张三'；
obj.age = 18；
obj.sex = '男'；
obj.sayHi = function () {
console.log('hi~')
}
// 利用等号 = 赋值的方法添加对象的属性和方法
// 每个属性和方法之间用分号结束

3）利用构造函数创建对象：因为前面两种方式一次只能创建一个对象
里面很多的属性和方法是大量相同的，只能复制，因此可以利用函数的
方法，重复这些相同的代码。把这个函数称为构造函数。
又因为这个函数里面封装的不是普通代码，而是对象。
构造函数 就是把对象里面一些相同的属性和方法抽象出来封装到函数
里面。
// 构造函数的语法格式
function 构造函数名() {     // 声明构造函数
this.属性 = 值；
this.方法 = function() {}
}
new 构造函数名()   // 调用构造函数
//  构造函数名字首字母要大写
//  构造函数不需要return就可以返回结果
//  调用构造函数必须使用 new
function Star(uname, age, sex) {
this.name = uname;
this.age = age;
this.sex = sex;
this.sing = function(sang) {
console.log(sang)
}
}
var ldh = new Star('刘德华', 18, '男 ');  //  返回的是一个对象
ldh.sing('冰雨')  ldh.name   ldh['sex']

构造函数和对象的区别：
构造函数：明星  泛指的某一大类   它类似java里面的  类(class)
对象： 特指某一具体的事物 刘德华={name: '刘德华', age: 18}
利用构造函数创建对象的过程称为对象的实例化。

new关键字的执行过程：
1. new构造函数可以在内存中创建了一个空对象；
2. this指向刚才创建的空对象
3. 执行构造函数里面的代码给这个空对象添加属性和方法
4. 返回这个新对象。

2、遍历对象属性
for...in 用于对于数组或对象的属性进行循环操作
for (变量 in 对象) {

}
for (var k in ibj) {
console.log(k)  // 变量输出得到的是属性名
console.log(obj[k])  //  obj[k] 得到的是属性值
}
// 使用for in 里面的变量，喜欢写key 或者 k

3.  内置对象：Math、Date、Array、String
JS对象：自定义对象、内置对象、浏览器对象
1) Math对象
不是一个构造器，所以不需要new调用，而是直接使用
里面的属性和对象。
Math.PI   //  圆周率
Math.floor()   //  向下取整，往小了取值
Math.ceil()  //  向上取整，往大了取值
Math.round() //  四舍五入
Math.abs()  //  绝对值，隐式转换会把字符串型-1转换成数字1
Math.max() / Math.min()  //  求最大值和最小值
Math.random()  返回一个随机小数[0, 1)，方法里面不跟参数
返回一个随机小数
2) Date 对象 通过new 操作符
1.参数的四种基本形式
 如果没有提供参数，那么新创建的Date对象表示实例化时刻的日期和时间
var date = new Date() 
一个时间戳
字符串 '2019-1-1 0:0:0'
数字型 2019, 10, 11
 		2.获得Date总的毫秒数，valueOf()、getTime()、Date.now() 
1) let date = new Date()
date.valueOf();  // 获取时间戳
date.getTime(); //  获取事件戳
Date.now() // 获取时间戳
+new Date() // 获取时间戳
2）倒计时案例  获取时间戳就是毫秒数
d = parseInt(总秒数/60/60/24) // 计算天数
h = parseInt(总秒数/60/60%24) // 计算小时
m = parseInt(总秒数/60%60) // 计算分钟
s = parseInt(总秒数%60) // 计算秒
3)Array 数组对象
1. 数组创建的两种方式
1.利用字面量  var arr = [ ];
var arr = [1, 2, 3]
2.利用new Array()
var arr1 = new Array()  // 创建了一个空数组
var arr1 = new Array(2) // 表示数组长度为2，里面有2个空的数组元素
var arr1 = new Array(2, 3) // 等价于[2, 3]
2.检测是否为数组
instanceof 可以检测是否为数组 arr instanceof array
Array.isArray(参数)
3.添加删除数组元素
push(ele1, ele2, ele...) 方法将一个或多个元素添加到数组的末尾会改变原数组，并返回该数组的新长度。
unshift((ele1, ele2, ele...) 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。
pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度
shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。
4.数组排序
arr.reverse()  返回颠倒后的数组，会改变原数组。
arr.sort()  对数组进行排序，并返回排序后的数组。
5.筛选数组
filter(callback(element[, index[, array]])) 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
var new_array = arr.map(function callback(currentValue[, index[, array]]) {
			 // Return element for new_array 
		}[, thisArg])
6.查找索引
arr.indexOf(searchElement[, fromIndex])方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。
     arr.lastIndexOf(searchElement[, fromIndex]) 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。
7.数组去重：遍历旧数组，拿旧数组元素查询新数组，如果有则不添加。（重点案例）
8.数组转换为字符串
1)   arr.toString()  返回指定字符串
2）arr.join(分隔符)
9.链接两个数组
var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])  返回新的数组
删除数组中的元素
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])有返回值，返回累计处理的结果。
arr.every(callback(element[, index[, array]])[, thisArg]) 测试一个数组内的所有元素是否都能通过某个指定函数的测试
arr.some(callback(element[, index[, array]])[, thisArg])测试数组中是不是至少有1个元素通过了被提供的函数测试
4）字符串对象
1. 基本包装类型：把简单数据类型包装成了复杂数据类型；三种特殊的引用类型：String Number
Boolean
2. 字符串的不可变性
3. 根据字符串返回位置：str.indexOf(元素，[开始的位置])
4.根据位置返回字符str[index] h5新增、charAt(index)、charCodeAt(index)
5. 拼接和截取字符串
   concat(str1, str2, str3...)  用于连接两个或者多个字符串，等效于+
   substr('截取的起始位置', '截取的个数')
   substring(strat, end)  从start位置开始截取到end位置，end取不到。
6.替换字符串以及转换为数组
   替换字符 replace('被替换的字符', '替换为的字符') 它只会替换第一个字符。
   字符转换为数组  split('分隔符')

十、DOM简介
1、DOM树：文档（页面）、元素（标签）、节点（标签、属性、文本、注释）
2、获取元素：
根据ID获取，根据标签名获取、通过H5新增的方法获取，特殊元素获取
getElementById() 返回的是对象
getElementsByTagName() 返回的是伪数组
获取父元素里面的子元素
element.getElementByTagName('标签名')   //  ol[0].getElementByTagName('li')
根据类名获取元素
document.getElementsByClassName('类名')
返回指定选择器的第一个元素对象，里面的选择器需要加符号
document.querySelector('.box') // querySelector('.box')
返回指定选择器所有的元素
document.querySelectorAll('.box')  
3、获取特殊元素
document.body()	 // 获取body元素
document.documentElement  // 获取html元素
4、事件基础
事件三要素：事件源：事件触发的对象 （按钮）
     事件类型：什么事件比如鼠标点击（onClick）、滑动、键盘按下
     事件处理程序：通过一个函数赋值的方式完成 btn.onClick = function() {}
改变元素的内容、属性；以下都是属性，采取等于
element.innerText  //  去除标签、空格、换行
element.innerHtml  //  包括标签、空格、换行
操作元素的属性
1、获取元素 let ldh = getElementById('ldh')  let img = getElementById('img')
2、注册事件及处理程序 ldh.onclick = function() {
img.src = 'hsakhauhhk'
}
3、表单元素的属性操作
type、value、checked、selected、disabled
btn.onclick = function() {
input.value =  '改变input输入框里面的值'
btn.disabled = true
this. disabled = true  // 同上效果，this 指向的是事件函数的调用者
}
案例：隐藏密码钥文点击切换
同一个按钮重复点击，利用一个flag变量，来判断flag的值
4、修改样式属性大小、颜色、位置
1. element.style  行内样式操作  // div.style.backgroundColor = 'pink'
JS里面的样式采取驼峰命名法，行内样式，权重比较高。
样式比较少，或者功能比较简单的情况下使用。
2. element.className   类名样式操作   // 给元素添加类名
// 让当前元素的类名改为了change，会覆盖原先的类名。
this.className = 'change'
// 如果想保留原先的类名，使用多类名选择器
this.className = 'first change'

5、排他思想
所有元素全部清除样式，给当前元素设置样式。

6、表单全选和取消全选
思路：1.点击全选：复选框跟随全选框
2.循环点击复选框，每次点击再循环一遍复选框，判断有无没选中的，设置变量来控制全选按钮是否选中

7、 获取元素的自定义属性
1.操作内置属性如：id，class  
使用element.属性
2.操作自定义属性： // 程序员自己添加的属性 index = '1'
element.getAttribute('属性')

8、设置元素的属性值
1.element.属性 = ‘值
   div.className = 'navs'
2.element.setAttribute('属性'， ‘值’)  //  操作自定义或者原先自带的属性
   div.seAttribute('class', 'navs')  

9、移除属性
element.removeAttribute('属性')

10、tab栏自定义切换
思路：排他思想、自定义属性
 
11、H5新增自定义属性：在页面中保存使用数据，有些自定义属性容易引起歧义
  规定自定义属性data-开头作为属性名并且赋值

<div data-index="1"></div>
或者JS设置
div.setAttribute('data-index', 1)

获取自定义属性
div.getAttribute('data-index')
// 如果自定义属性里面有多个-连接的单词，获取的时候采取驼峰命名法，只能获取data-开头的
H5新增element.dataset.index  或者 element.dataset['index']    //  ie11以上才支持

十一、节点操作
1、DOM提供的方法获取元素繁琐，逻辑性不强。
2、利用父子兄节点操作，逻辑性强，兼容性稍差，更简单一些。
节点概述：节点一般至少包括nodeType、nodeName、nodeValuez这三个基本属性
节点操作主要操作的是元素节点。
父节点：parentNode  //  得到的是离元素最近的父节点，如果找不到就返回 null
子节点：childNodes  //  返回包含子节点的集合，包含元素节点、文本节点等，一般不提倡
   children  // 返回所有子元素的节点。实际开发常用。
3、节点操作获取第一个子元素和最后一个子元素
firstChild  获取第一个子节点，不管是文本还是元素都可以拿到。
lastChild  获取最后一个节点，不管是文本还是元素都可以拿到。
firstElementChild 获取第一个子元素节点  IE9以上支持。
lastElementChild 获取最后一个子元素节点，IE9以上支持。
下面两个最实用：
// 实际开发中 ol.children[0]  第一个子元素节点
ol.children[ol.children.length-1]  最后一个元素节点

案例：下拉菜单，采用子节点对应得显示。

4、兄弟节点
 nextSibling  返回当前元素的下一个节点，包含文本节点或者元素节点，找不到就返回null
 previousSibling  返回当前元素的上一个节点，包含文本节点或者元素节点，找不到就返回null

nextElementSibling 下一个兄弟节点,找不到就返回null  IE9以上支持。
previousElementSibling 上一个兄弟节点,找不到就返回null  IE9以上支持。

5、页面添加一个新元素。1创建元素，2添加元素。

1.动态创建元素节点	
var li = document.createElement('li')
2.在子节点末尾添加节点
父级.appendChild(子级)   //  将一个节点添加到指定父节点的子节点末尾
ul.appendChild(li)
在子节点前面添加节点
父级.insertBefore(child，指定元素)  
ul.insertBefore(lili,  ul.children[0])

留言板案例：
添加节点，给元素添加内容	
删除留言板
给li赋值时多加一个删除的链接，阻止链接跳转javascript:void(0); 或者 javascript:;
删除的是当前链接的父节点li

6、删除节点
父节点.removeChild(子节点)  //  删除父节点中的子节点

7、复制节点
node.cloneNode()  // 拷贝节点
如果括号为true，就是深拷贝，会复制标签里面的内容
如果参数为空或者false，就是浅拷贝，只复制节点本身，不包括里面的子节点

案例动态生成表格
思路：根据数据动态添加行和列
1、有几条数据就创建几行，2.有几个属性就创建几个单元格，3、在每行追加删除单元格

8、三种动态创建元素的区别
window.onload = function () {  //  页面加载完毕加载JS
document.write('<div>123</div>')
}
document.write( )  页面文档流加载完毕(比如事件)会导致页面重绘
element.innerHTML  采取数组形式效率最高，字符串效率最低
document.creatElement( )  效率稍微低一点
